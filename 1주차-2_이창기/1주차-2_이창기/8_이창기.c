/*
	1. 빙고에 넣을 수 25개만큼 입력 받고 이중배열에 데이터 넣기.
	2. 사회자가 부른 수 25개만큼 입력 받고 기존 이중배열에 있는 수와 비교하기. 
	3. 비교해서 맞을 경우 데이터를 0으로 변경.
	4. 대각선, 가로, 세로가 모두 0일 경우 bingo 값이 1 증가하도록 설정.
	5. 빙고값이 3이될 때 값 출력. (5*i+j)
*/
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
int main(void) {
	int i, j, k, l, m, n, arr[7][7] = { 0,0 }, arr2[7][7] = { 0,0 }, tmp[7][7] = { 0,0 }; // 빙고가 중복되서 세지지 않도록 tmp 배열 마지막에 하나 더 만듦.
	int x = 0, y = 0, bingo = 0;
	// 1,2번 과정
	for (i = 1; i <= 5; i++) {
		for (j = 1; j <= 5; j++) {
			scanf("%d", &arr[i][j]);
		}
	}
	for (i = 1; i <= 5; i++) {
		for (j = 1; j <= 5; j++) {
			scanf("%d", &arr2[i][j]);
		}
	}

	// 3번 (겉에 두 반복문은 불린 수 , 안의 두 반복문은 빙고의 수)
	for (i = 1; i <= 5; i++) {
		for (j = 1; j <= 5; j++) {
			if (bingo < 3) {	// 이거 없어서 자꾸 x,y 값이 변경되는 바람에 예제 출력보다 크게나옴.
				// 불린 수와 빙고 수 체크 과정 (이중 반복문)
				for (k = 1; k <= 5; k++) {
					for (l = 1; l <= 5; l++) {
						if (arr2[i][j] == arr[k][l]) {
							arr[k][l] = -1;		// arr[k][l] 값이 -1 이라는 것은 X표시 됐다는 것.
						}
					}
				}
				for (m = 1; m <= 5; m++) {
					if (arr[1][m] == -1 && arr[2][m] == -1 && arr[3][m] == -1 && arr[4][m] == -1 && arr[5][m] == -1 && tmp[0][m] != -1) {
						tmp[0][m] = -1;
						bingo++;
					}
				}
				for (n = 1; n <= 5; n++) {
					if (arr[n][1] == -1 && arr[n][2] == -1 && arr[n][3] == -1 && arr[n][4] == -1 && arr[n][5] == -1 && tmp[n][0] != -1) {
						tmp[n][0] = -1;
						bingo++;
					}
				}
				if (arr[1][1] == -1 && arr[2][2] == -1 && arr[3][3] == -1 && arr[4][4] == -1 && arr[5][5] == -1 && tmp[1][1] != -1) {
					tmp[1][1] = -1;
					bingo++;
				}
				if (arr[1][5] == -1 && arr[2][4] == -1 && arr[3][3] == -1 && arr[4][2] == -1 && arr[5][1] == -1 && tmp[0][0] != -1) {
					tmp[0][0] = -1;
					bingo++;
				}
				if (bingo == 3) {
					x = j;		// x,y 순서 바꿔 입력 안하도록 주의하기 벌써 여러번째...
					y = i;
				}
			}
		}
	}

	// 출력


	printf("%d", 5 * (y - 1) + x);

	return 0;
}